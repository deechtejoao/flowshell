package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

func main() {
	dir := "."

	// Parse the entire directory.
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("parse error: %v", err)
	}

	if len(pkgs) != 1 {
		log.Fatalf("expected exactly one package in directory")
	}

	var pkg *ast.Package //nolint:staticcheck
	for _, p := range pkgs {
		pkg = p
		break
	}

	var pkgName string
	var decls []string

	// Scan all files for `GEN:NodeAction` markers.
	for _, f := range pkg.Files {
		if pkgName == "" {
			pkgName = f.Name.Name
		}

		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}

			// Look for a "GEN:NodeAction" comment on or before the decl.
			if !hasGenTag(gen.Doc, "NodeAction") {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				decls = append(decls, ts.Name.Name)
			}
		}
	}
	slices.Sort(decls)

	// Generate code
	var b strings.Builder
	fmt.Fprintf(&b, "// Code generated by gen_node_actions.go; DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "\n")
	fmt.Fprintf(&b, "package %s\n", pkg.Name)
	fmt.Fprintf(&b, "\n")
	fmt.Fprintf(&b, "var allNodeActions = [...]NodeActionMeta{\n")
	for _, name := range decls {
		fmt.Fprintf(&b, "  { Tag: %q, Alloc: func() NodeAction { return &%s{} } },\n", name, name)
	}
	fmt.Fprintf(&b, "}\n")
	fmt.Fprintf(&b, "\n")
	for _, name := range decls {
		fmt.Fprintf(&b, "func (a *%s) Tag() string {\n", name)
		fmt.Fprintf(&b, "  return %q\n", name)
		fmt.Fprintf(&b, "}\n")
		fmt.Fprintf(&b, "\n")
	}

	// Format the generated source
	src, err := format.Source([]byte(b.String()))
	if err != nil {
		log.Fatalf("formatting failed: %v", err)
	}

	// Write to file
	filename := filepath.Join(".", "node_actions_generated.go")
	if err := os.WriteFile(filename, src, 0o644); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("âœ… Generated metadata for %d node actions\n", len(decls))
}

var reGenComment = regexp.MustCompile(`^\s*(?:/*|//)\s*GEN:([a-zA-Z0-9_,-]*)`)

func hasGenTag(doc *ast.CommentGroup, tag string) bool {
	if doc == nil {
		return false
	}
	for _, c := range doc.List {
		lines := strings.SplitSeq(c.Text, "\n")
		for line := range lines {
			if match := reGenComment.FindStringSubmatch(line); match != nil {
				tags := strings.Split(match[1], ",")
				if slices.Contains(tags, tag) {
					return true
				}
			}
		}
	}
	return false
}
